/*;-: -------------------------------------------------------------------------------------------------------
;-: The Dyson Sphere: Dynamic Measure Engine
;-: -------------------------------------------------------------------------------------------------------
;-:
;-: DESIGN INTENT:
;-: A single [Calc] dispatcher measure acts as the engine for the entire report.
;-: Rather than placing 20 individual measures on every visual, all base metrics
;-: are routed through one measure that responds to a slicer selection.
;-: This eliminates visual bloat, enforces consistency, and allows downstream
;-: measures (PY, YoY, CY/GT%, format strings) to inherit the selection automatically.
;-:
;-: NAMING CONVENTION:
;-: Base measures use a suffix pattern to encode data type:
;-:   _MeasureName$   → currency
;-:   _MeasureName%   → percentage
;-:   _MeasureNameCT  → count/integer
;-: This convention is later exploited by the Format String Expression
;-: to apply the correct number format without a separate format lookup table per measure.
;-: -------------------------------------------------------------------------------------------------------*/


/*=======================================================
INTEGRATION STEPS SUMMARIZED
=======================================================
1) Create base measures with suffix naming (_NetSls$, _Margin%, _OrderCT)
2) Create Calc field parameter table — one row per measure name string
3) Create format flag tables:
      Flag_Currency → user-selectable currency symbols
      Flag_Fmt      → PATHITEM arrays encoding format strings per data type
4) Add [Calc] dispatcher measure (routes slicer → measure)
5) Add Format String Expression to dynamically format visuals
=======================================================*/


/*=======================================================
[1] DYNAMIC DISPATCHER — [Calc]
=======================================================
Purpose:
    Single entry point for all base metrics across the report.
    Reads the slicer selection from Calc[Base] and routes to
    the corresponding base measure.

Why SELECTEDVALUE with a default:
    The default "NetSls$" ensures visuals never return BLANK
    when no slicer selection is active — the report always
    shows something meaningful on load.

Why a SWITCH instead of field parameters alone:
    Field parameters natively swap column references, not measure
    references. Using SWITCH(SELECTEDVALUE(...)) gives full control
    over which DAX measure is evaluated, including measures with
    complex logic that field parameters can't handle directly.
=======================================================*/

Calc = SWITCH(SELECTEDVALUE(Calc[Base],"NetSls$"),
	"NetUnits",    [_NetUnits],
	"Cost$",       [_Cost$],
    "DateCT",      [_DateCT],
    "Discount$",   [_Discount$],
    "Gross$",      [_Gross$],
    "Margin$",     [_Margin$],
    "Margin%",     [_Margin%],
    "OrderCT",     [_OrderCT],
    "ProductCT",   [_ProductCT],
    "SalesRtn%",   [_SalesRtn%],
    "Sales$",      [_Sales$],
    "Returns$",    [_Returns$],
    "UnitRtn%",    [_UnitRtn%],
    "PriceEff%",   [_PriceEff%],
    "MgnPerOrd",   [_Mgn$PerOrd],
    "Loss$PerOrd", [_Loss$PerOrd],
    "NetLoss$",    [_Deductions$],
    "NetLoss%",    [_Deductions%],
    "UnitRtn",     [_UnitRtn],
	"NetSls$",     [_NetSls$],
                   [_NetSls$]   -- fallback: unmatched selection defaults to Net Sales
)
--;-: ----------------------------------------------------------------------------------;-:


/*=======================================================
[PY] — Prior Year
=======================================================
Purpose:
    Calculates the prior year equivalent of whatever [Calc]
    is currently returning, respecting any active slicer context.

Why REMOVEFILTERS(DateFilter[Year]):
    The report uses a separate DateFilter[Year] slicer to control
    the current year in context. Without removing this filter,
    SAMEPERIODLASTYEAR would shift within an already-filtered year,
    producing incorrect or BLANK results.

Why [Calc] and not a hardcoded measure:
    PY inherits the dispatcher — switching the metric slicer
    automatically updates PY without any additional configuration.
=======================================================*/

PY = CALCULATE(
    [Calc],
    REMOVEFILTERS(DateFilter[Year]),          -- lift the year slicer so SAMEPERIODLASTYEAR can shift back
    SAMEPERIODLASTYEAR(CalendarDates[Date])   -- shift the date context back exactly one year
)
--;-: ----------------------------------------------------------------------------------;-:


/*=======================================================
[CY/GT%] — Current Year vs Grand Total Percentage
=======================================================
Purpose:
    Calculates the share of the current row's [Calc] value
    relative to its logical parent total — context-aware
    across Customer, Location, and Product hierarchies.

Design Pattern — Context-Sensitive Parent:
    ISINSCOPE detects which level of a hierarchy is currently
    rendering, then removes filters at that level to compute
    the appropriate denominator.

    Examples:
      - Row = State      → Parent = all States (country total)
      - Row = AccountType → Parent = all AccountTypes (full customer total)
      - Row = Product    → Parent = all Products

Why SWITCH(TRUE,...) with ISINSCOPE:
    This is the standard pattern for hierarchy-aware calculations
    in Power BI. Evaluation order matters — more granular scopes
    must be checked before broader ones to avoid incorrect parent
    resolution.

Why DIVIDE at the end:
    Safe division — returns BLANK instead of error when _P is zero.
=======================================================*/

CY/GT% = 
VAR _P = SWITCH(TRUE,

    -- Customer hierarchy (granular → broad)
    ISINSCOPE(Customer[CustomerIndex]),
        CALCULATE([Calc], ALL(Customer[CustomerIndex])),              -- row = individual customer → parent = account type total
    ISINSCOPE(Customer[AccountTypeCd]),
        CALCULATE([Calc], ALLEXCEPT(Customer, Customer[AccountType])),-- row = account code → parent = account type
    ISINSCOPE(Customer[AccountType]),
        CALCULATE([Calc], ALL(Customer)),                             -- row = account type → parent = all customers

    -- Location hierarchy (granular → broad)
    ISINSCOPE(Location[State/Province Name]) || ISINSCOPE(Location[State/Province]),
        CALCULATE([Calc], ALL(Location[State/Province], Location[State/Province Name])), -- row = state → parent = region
    ISINSCOPE(Location[Division]),
        CALCULATE([Calc], ALLEXCEPT(Location, Location[Region], Location[Country])),     -- row = division → parent = region
    ISINSCOPE(Location[Region]),
        CALCULATE([Calc], ALLEXCEPT(Location, Location[Country])),   -- row = region → parent = country
    ISINSCOPE(Location[Country]),
        CALCULATE([Calc], ALL(Location)),                            -- row = country → parent = all locations

    -- Product hierarchy (granular → broad)
    ISINSCOPE(Product[Product]),
        CALCULATE([Calc], ALL(Product[Product])),                    -- row = product → parent = product type
    ISINSCOPE(Product[ProductType]),
        CALCULATE([Calc], ALLEXCEPT(Product, Product[Goods])),       -- row = product type → parent = goods category
    ISINSCOPE(Product[Goods]),
        CALCULATE([Calc], ALL(Product))                              -- row = goods → parent = all products
)
RETURN
DIVIDE([Calc], _P)
--;-: ----------------------------------------------------------------------------------;-:


/*=======================================================
[YoY] — Year over Year Absolute Change
=======================================================
Purpose:
    Absolute delta between current and prior year for [Calc].

Why the double ISBLANK guard:
    If either [Calc] or [PY] is BLANK (e.g. a new product with
    no prior year data, or a future date), the result should be
    BLANK — not zero. Returning zero would misrepresent the data.
=======================================================*/

YoY = IF(
    NOT(ISBLANK([Calc]) || ISBLANK([PY])),
    [Calc] - [PY]
)
--;-: ----------------------------------------------------------------------------------;-:


/*=======================================================
[YoY%] — Year over Year Percentage Change
=======================================================
Purpose:
    Percentage change from prior year to current year.

Why ABS([PY]) as denominator:
    If [PY] is negative (e.g. a loss metric), a naive divide
    would flip the sign of the percentage, making an improvement
    appear as a decline. ABS ensures the direction of change
    is always expressed correctly relative to magnitude.
=======================================================*/

YoY% = DIVIDE([YoY], ABS([PY]))
--;-: ----------------------------------------------------------------------------------;-:


/*=======================================================
[YoYperformance] — Relative YoY Performance vs Peer Group
=======================================================
Purpose:
    Measures how a row's YoY% compares to the average YoY%
    across its peer group (siblings in the same hierarchy level).
    Used for conditional formatting or performance banding —
    highlights which regions/products are outperforming or
    underperforming their cohort, not just the overall average.

How it works:
    1. Compute the peer group's YoY% using ALLSELECTED at the
       appropriate hierarchy level
    2. Subtract peer average from the row's YoY%
    3. Scale to a -100 to +100 range for consistent conditional
       formatting regardless of metric magnitude

Why cap at ±100:
    Extreme outliers (e.g. a new product going from $1 to $1000
    YoY) would distort color scales. Capping normalizes the
    signal without losing directionality.
=======================================================*/

YoYperformance = 
VAR _P = SWITCH(TRUE,
    ISINSCOPE(Location[Region]),
        CALCULATE([YoY%], ALLSELECTED(Location[Region])),
    ISINSCOPE(Location[State/Province Name]),
        CALCULATE([YoY%], ALLSELECTED(Location[State/Province Name])),
    ISINSCOPE(Product[ProductType]),
        CALCULATE([YoY%], ALLSELECTED(Product[ProductType])),
    ISINSCOPE(Product[Product]),
        CALCULATE([YoY%], ALLSELECTED(Product[Product]))
)
VAR _R = ([YoY%] - _P) * 100   -- delta from peer average, scaled to integer range
RETURN
IF(_R > 100, 100, IF(_R < -100, -100, _R))   -- cap to ±100 for formatting stability
--;-: ----------------------------------------------------------------------------------;-:


/*=======================================================
[3Y-CAGR%] — 3-Year Compound Annual Growth Rate
=======================================================
Purpose:
    Calculates CAGR over a 3-year window — or the full available
    range if the data spans less than 3 years.

Context-aware start year:
    - When a year is in scope (row-level in a matrix), StartYr = EndYr - 2
      to anchor a rolling 3-year window at each row.
    - When no year is in scope (total row), StartYr = MIN year in the
      dataset so the CAGR reflects the entire data range.

Formula: (EndValue / StartValue) ^ (1 / Years) - 1
    Standard CAGR formula. POWER handles the nth root.

Guard conditions:
    - _T > 0: Prevents division by zero when start and end year are the same
    - NOT ISBLANK(SalesStart): Prevents errors when the metric has no data
      in the start year (e.g. a new product line)
=======================================================*/

3Y-CAGR% = 
VAR EndYr    = MAX(CalendarDates[Year])
VAR StartYr  = IF(ISINSCOPE('CalendarDates'[Year]), EndYr - 2, MIN(CalendarDates[Year]))
VAR _T       = EndYr - StartYr
VAR SalesEnd = CALCULATE([Calc], CalendarDates[Year] = EndYr)
VAR SalesStart = CALCULATE([Calc], CalendarDates[Year] = StartYr)
RETURN
IF(
    _T > 0 && NOT ISBLANK(SalesStart),
    POWER(DIVIDE(SalesEnd, SalesStart), 1 / _T) - 1
)


/*=======================================================
[2] CURRENCY TABLE (M Query — Power Query)
=======================================================
Purpose:
    Provides a user-selectable currency symbol that propagates
    into the Format String Expression, enabling multi-currency
    display without duplicating measures.

Structure:
    Columns: Currency code | Symbol | Description
    Example row: USD | $ | United States Dollar

Implementation note:
    Currently a static compressed lookup table in M.
    Extension path: replace static table with a live exchange
    rate API call to support currency conversion, not just
    symbol substitution.
=======================================================*/


/*=======================================================
[3] FORMAT STRING EXPRESSION
=======================================================
Purpose:
    Dynamically applies the correct number format to visuals
    based on the active [Calc] selection and currency choice —
    without hardcoding format strings into individual measures
    or visual properties.

Architecture:
    Three supporting measures feed into the format expression:
      [sv_CalcBase]  → captures the active metric name string
      [FLGrpA]       → resolves the currency-aware format string array
    The format expression then parses the metric name suffix
    to determine which format slot to apply.

Why parse the measure name instead of a lookup table:
    The suffix naming convention (_$, _%, CT) encodes the data
    type directly in the measure name. Parsing it avoids
    maintaining a separate format mapping table that would need
    updating every time a new measure is added.
=======================================================*/

-- Captures the active slicer selection as a string for downstream parsing
sv_CalcBase = SELECTEDVALUE(Calc[Base], "NetSls$")
--;-: ----------------------------------------------------------------------------------;-:

-- Resolves the currency-aware format string array
-- Flag_Fmt[GrpA] stores a PATHITEM-encoded string: "PctFmt|CurrencyFmt|UnitFmt"
-- The "$" placeholder in the template is replaced with the selected currency symbol
FLGrpA = 
VAR SYM = SELECTEDVALUE(Flag_Currency[Symbol], "$")   -- default to USD if no selection
RETURN
SUBSTITUTE(SELECTEDVALUE(Flag_Fmt[GrpA]), "$", SYM)   -- inject selected symbol into format template
--;-: ----------------------------------------------------------------------------------;-:

-- Main format string resolver
-- Reads the measure name, determines data type from suffix, returns the correct format string
VAR SMN     = [sv_CalcBase]          -- active measure name string
VAR Fmt     = PATHITEM([FLGrpA], 2)  -- slot 2: currency format (e.g. "$#,0.00")
VAR FmtPrc  = PATHITEM([FLGrpA], 1)  -- slot 1: percentage format (e.g. "0.0%")
VAR FmtUnt  = PATHITEM([FLGrpA], 3)  -- slot 3: unit/count format (e.g. "#,0")

VAR FMTString = SWITCH(TRUE,

    -- Variance/delta percentage measures use a fixed 2-decimal format
    -- regardless of currency setting (vM* and ΔM* prefixes are internal variance naming)
    CONTAINSSTRING(SMN, "vM*Pct") || CONTAINSSTRING(SMN, "vM*%")
        || CONTAINSSTRING(SMN, "ΔM*Pct") || CONTAINSSTRING(SMN, "ΔM*%"),
        "0.00",

    -- Percentage measures: name contains "%" or "pct"
    CONTAINSSTRING(SMN, "%") || CONTAINSSTRING(SMN, "pct"),
        FmtPrc,

    -- Count/unit measures: detected by common naming patterns
    -- CONTAINSSTRINGEXACT used where suffix match must be precise (e.g. "CT" at end of name)
    CONTAINSSTRING(SMN, "unit")
        || CONTAINSSTRING(SMN, "Qty")
        || CONTAINSSTRING(SMN, "Quantity")
        || CONTAINSSTRINGEXACT(RIGHT(SMN, 2), "CT")
        || CONTAINSSTRINGEXACT(SMN, "CNT")
        || CONTAINSSTRINGEXACT(SMN, "Count"),
        FmtUnt,

    -- Default: currency format
    Fmt
)
RETURN
FMTString & ""   -- concatenate empty string to coerce result to text type for format string expression
